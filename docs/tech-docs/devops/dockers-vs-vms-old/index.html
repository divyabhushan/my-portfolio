<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.ff31de0ff">
<link rel="alternate" type="application/rss+xml" href="/my-portfolio/blog/rss.xml" title="Divya Bhushan - Senior Technical Writer Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/my-portfolio/blog/atom.xml" title="Divya Bhushan - Senior Technical Writer Blog Atom Feed">
<link rel="preconnect" href="https://www.google-analytics.com">
<script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-139623144-1","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")</script>
<script async src="https://www.google-analytics.com/analytics.js"></script>
<link rel="preconnect" href="https://www.google-analytics.com">
<script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-139623144-1","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")</script>
<script async src="https://www.google-analytics.com/analytics.js"></script><title data-react-helmet="true">Docker Vs Virtual Machines(VMs) | Divya Bhushan - Senior Technical Writer</title><meta data-react-helmet="true" property="og:url" content="https://github.com/divyabhushan/my-portfolio/my-portfolio/docs/tech-docs/devops/dockers-vs-vms-old"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="Docker Vs Virtual Machines(VMs) | Divya Bhushan - Senior Technical Writer"><meta data-react-helmet="true" name="description" content="Let‚Äôs have a quick warm up on the resource management before we dive into the discussion on virtualization and dockers."><meta data-react-helmet="true" property="og:description" content="Let‚Äôs have a quick warm up on the resource management before we dive into the discussion on virtualization and dockers."><link data-react-helmet="true" rel="shortcut icon" href="/my-portfolio/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://github.com/divyabhushan/my-portfolio/my-portfolio/docs/tech-docs/devops/dockers-vs-vms-old"><link data-react-helmet="true" rel="alternate" href="https://github.com/divyabhushan/my-portfolio/my-portfolio/docs/tech-docs/devops/dockers-vs-vms-old" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://github.com/divyabhushan/my-portfolio/my-portfolio/docs/tech-docs/devops/dockers-vs-vms-old" hreflang="x-default"><link rel="stylesheet" href="/my-portfolio/assets/css/styles.e1f98912.css">
<link rel="preload" href="/my-portfolio/assets/js/runtime~main.d2cc5123.js" as="script">
<link rel="preload" href="/my-portfolio/assets/js/main.3f25e7fb.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#main" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle" type="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/my-portfolio/"><strong class="navbar__title">Home</strong></a><a class="navbar__item navbar__link" href="/my-portfolio/docs/about-me">About Me</a><a class="navbar__item navbar__link" href="/my-portfolio/portfolio">Portfolio</a></div><div class="navbar__items navbar__items--right"><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/my-portfolio/docs/tech-docs/docusaurus/robots">Technical Docs</a><ul class="dropdown__menu"><li><a class="dropdown__link" type="doc" docid="docs/tech-docs/docusaurus/robots" activesidebarclassname="navbar__link--active" href="/my-portfolio/docs/tech-docs/docusaurus/robots">Robots.txt File</a></li><li><a class="dropdown__link" type="doc" docid="docs/tech-docs/docusaurus/lunr-search" activesidebarclassname="navbar__link--active" href="/my-portfolio/docs/tech-docs/docusaurus/lunr-search">Enable Lunr Search</a></li><li><a class="dropdown__link" type="doc" docid="docs/tech-docs/visualbi-prods/valq-prod-doc-project" activesidebarclassname="navbar__link--active" href="/my-portfolio/docs/tech-docs/visualbi-prods/valq-prod-doc-project">ValQ Product</a></li><li><a class="dropdown__link" type="doc" docid="docs/tech-docs/git/git-tutorial" activesidebarclassname="navbar__link--active" href="/my-portfolio/docs/tech-docs/git/git-tutorial">Git Tutorial</a></li><li><a class="dropdown__link" type="doc" docid="docs/tech-docs/git/git-branch-strategy" activesidebarclassname="navbar__link--active" href="/my-portfolio/docs/tech-docs/git/git-branch-strategy">Git Branch Strategy</a></li><li><a class="dropdown__link" type="doc" docid="docs/tech-docs/git/git-basics" activesidebarclassname="navbar__link--active" href="/my-portfolio/docs/tech-docs/git/git-basics">Git Basics</a></li><li><a class="dropdown__link" type="doc" docid="docs/tech-docs/git/fix-mistakes" activesidebarclassname="navbar__link--active" href="/my-portfolio/docs/tech-docs/git/fix-mistakes">Fix Git Mistakes</a></li><li><a class="dropdown__link" type="doc" docid="docs/tech-docs/git/git-log" activesidebarclassname="navbar__link--active" href="/my-portfolio/docs/tech-docs/git/git-log">Git Log</a></li><li><a class="dropdown__link" type="doc" docid="docs/tech-docs/git/reflog" activesidebarclassname="navbar__link--active" href="/my-portfolio/docs/tech-docs/git/reflog">Git Reflog</a></li><li><a class="dropdown__link" type="doc" docid="docs/tech-docs/git/git-bisect" activesidebarclassname="navbar__link--active" href="/my-portfolio/docs/tech-docs/git/git-bisect">Git Bisect</a></li><li><a class="dropdown__link" type="doc" docid="docs/tech-docs/devops/dockers-vs-vms" activesidebarclassname="navbar__link--active" href="/my-portfolio/docs/tech-docs/devops/dockers-vs-vms">Dockers Vs VMs</a></li><li><a class="dropdown__link" type="doc" docid="docs/tech-docs/devops/devops-roadmap" activesidebarclassname="navbar__link--active" href="/my-portfolio/docs/tech-docs/devops/devops-roadmap">DevOps Roadmap</a></li></ul></div><a href="https://github.com/divyabhushan" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a><div class="react-toggle displayOnlyInLargeViewport_GrZ2 react-toggle--disabled" role="button" tabindex="-1"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_71bT">üåú</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">üåû</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/my-portfolio/"><strong class="navbar__title">Home</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/my-portfolio/docs/about-me">About Me</a></li><li class="menu__list-item menu__list-item--collapsed"><a aria-current="page" class="menu__link menu__link--sublist navbar__link--active" role="button" href="/my-portfolio/docs/tech-docs/docusaurus/robots">Technical Docs</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" type="doc" docid="docs/tech-docs/docusaurus/robots" activesidebarclassname="navbar__link--active" href="/my-portfolio/docs/tech-docs/docusaurus/robots">Robots.txt File</a></li><li class="menu__list-item"><a class="menu__link" type="doc" docid="docs/tech-docs/docusaurus/lunr-search" activesidebarclassname="navbar__link--active" href="/my-portfolio/docs/tech-docs/docusaurus/lunr-search">Enable Lunr Search</a></li><li class="menu__list-item"><a class="menu__link" type="doc" docid="docs/tech-docs/visualbi-prods/valq-prod-doc-project" activesidebarclassname="navbar__link--active" href="/my-portfolio/docs/tech-docs/visualbi-prods/valq-prod-doc-project">ValQ Product</a></li><li class="menu__list-item"><a class="menu__link" type="doc" docid="docs/tech-docs/git/git-tutorial" activesidebarclassname="navbar__link--active" href="/my-portfolio/docs/tech-docs/git/git-tutorial">Git Tutorial</a></li><li class="menu__list-item"><a class="menu__link" type="doc" docid="docs/tech-docs/git/git-branch-strategy" activesidebarclassname="navbar__link--active" href="/my-portfolio/docs/tech-docs/git/git-branch-strategy">Git Branch Strategy</a></li><li class="menu__list-item"><a class="menu__link" type="doc" docid="docs/tech-docs/git/git-basics" activesidebarclassname="navbar__link--active" href="/my-portfolio/docs/tech-docs/git/git-basics">Git Basics</a></li><li class="menu__list-item"><a class="menu__link" type="doc" docid="docs/tech-docs/git/fix-mistakes" activesidebarclassname="navbar__link--active" href="/my-portfolio/docs/tech-docs/git/fix-mistakes">Fix Git Mistakes</a></li><li class="menu__list-item"><a class="menu__link" type="doc" docid="docs/tech-docs/git/git-log" activesidebarclassname="navbar__link--active" href="/my-portfolio/docs/tech-docs/git/git-log">Git Log</a></li><li class="menu__list-item"><a class="menu__link" type="doc" docid="docs/tech-docs/git/reflog" activesidebarclassname="navbar__link--active" href="/my-portfolio/docs/tech-docs/git/reflog">Git Reflog</a></li><li class="menu__list-item"><a class="menu__link" type="doc" docid="docs/tech-docs/git/git-bisect" activesidebarclassname="navbar__link--active" href="/my-portfolio/docs/tech-docs/git/git-bisect">Git Bisect</a></li><li class="menu__list-item"><a class="menu__link" type="doc" docid="docs/tech-docs/devops/dockers-vs-vms" activesidebarclassname="navbar__link--active" href="/my-portfolio/docs/tech-docs/devops/dockers-vs-vms">Dockers Vs VMs</a></li><li class="menu__list-item"><a class="menu__link" type="doc" docid="docs/tech-docs/devops/devops-roadmap" activesidebarclassname="navbar__link--active" href="/my-portfolio/docs/tech-docs/devops/devops-roadmap">DevOps Roadmap</a></li></ul></li><li class="menu__list-item"><a class="menu__link" href="/my-portfolio/portfolio">Portfolio</a></li><li class="menu__list-item"><a href="https://github.com/divyabhushan" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_31aa"><main class="docMainContainer_3ufF docMainContainerEnhanced_3NYZ"><div class="container padding-vert--lg docItemWrapper_3FMP"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><header><h1 class="docTitle_3a4h">Docker Vs Virtual Machines(VMs)</h1></header><div class="markdown"><p>Let‚Äôs have a quick warm up on the resource management before we dive into the discussion on virtualization and dockers.</p><p>In today‚Äôs multi-technology environments, it becomes inevitable to work on different software and hardware platforms simultaneously.</p><p>The need to run multiple different machines (Desktops, Laptops, handhelds, and Servers) platforms with customized hardware and software requirements has given the rise to a new world of <em>virtualization</em> in IT industry.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="what-a-machine-need"></a><strong>What a machine need?</strong><a class="hash-link" href="#what-a-machine-need" title="Direct link to heading">#</a></h2><p>Each computing environment(machine) needs its own component of <em>hardware resources</em> and <em>software resources.</em></p><p>As more and more machines are needed, building up and administering many such stand-alone machines is not only cumbersome, time consuming but also adds up to the cost and energy.</p><p>Apparently; to run a customized <em>High-power</em> <em>Scalable</em> <em>Server</em> is a better idea to consolidate all the hardware and software requirements into one place and have a single server run and distribute the resources to many machines over a network.</p><p>That saves us time, resources, energy and revenue.</p><p>These gigantic servers are stored in a data warehouse called a <em>Datacenter__.</em></p><p>Below Diagram (2) indicates a single <em>server</em> serving and sharing resources and data among multiple client machines</p><p>Does this look simplified enough? Yes of course!</p><p>So, this setup looks feasible we have a high-power, high-storage Server that gives resources to many smaller(resources) machines over a network.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="how-to-manage-huge-data---servers"></a><strong>How to manage huge data - Servers</strong><a class="hash-link" href="#how-to-manage-huge-data---servers" title="Direct link to heading">#</a></h2><p>With <em>Internet Of Things</em> in boom, Information is overflowing with a huge amount of data; handling tremendous data needs more system resources which means more _Dedicated server_s are needed.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="many-servers-approach-challenge"></a><strong>Many Servers approach challenge:</strong><a class="hash-link" href="#many-servers-approach-challenge" title="Direct link to heading">#</a></h3><p>Running several <em>Dedicated servers</em> for specific services such as Web service, application or database service as indicated in Diagram (3) is difficult to administer and consumes more energy, resources, manpower and is highly expensive.</p><p>In addition; resource utilization of servers is very poor resulting in resource wastage.</p><p>This is where simulating different environments and running them all on a single server is a smart choice; rather than having to run multiple physically distinct servers.</p><p>This is how Diagram (3) would change after consolidating different servers into one as shown in Diagram (4).</p><p>Sheet 2</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="virtualization"></a><strong>Virtualization</strong><a class="hash-link" href="#virtualization" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="what-is-virtualization"></a>What is Virtualization<a class="hash-link" href="#what-is-virtualization" title="Direct link to heading">#</a></h3><p>The above single server implementation can be defined as the following term.</p><p><em>Virtualization</em> is a technique used to simulate and <em>pretend a single infrastructure</em> resource (<em>hardware resources</em> and <em>software resources</em>) <em>to be acting as many</em> providing multiple functionalities or services without the need to physically build, install and configure.</p><p>In other words;</p><p>Running <em>multiple simulated environments in a single machine without installing and configuring them</em> is called <em>Virtualization</em>.</p><p>Technically speaking;</p><p>Virtualization is an abstract layer that shares the infrastructure resources among various simulated <em>virtual machines</em> without the need to physically set up these environments.</p><p>Diagram (5) displays different virtual Operating systems are running on the same machine and using the same hardware architecture of the underlying machine.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="what-is-a-virtual-machine"></a><em>What is a Virtual machine</em><a class="hash-link" href="#what-is-a-virtual-machine" title="Direct link to heading">#</a></h3><p>The simulated virtualized environments are called virtual machines or VM.</p><p>Virtual machine is a <em>replication/simulation</em> of an actual physical machine.</p><p>A VM acts like a real physical machine and uses the physical resources of the underlying host OS.</p><p>A VM is a running <em>instance of a real physical machine.</em></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="need-for-virtualization"></a><em>Need</em> <em>for</em> <em>virtualization</em><a class="hash-link" href="#need-for-virtualization" title="Direct link to heading">#</a></h3><p>So; we have an overview of virtualization, let us examine when should we virtualize and what are the benefits of virtualization?</p><ol><li><strong>Better resource management and</strong> <strong>cost-effective</strong>: as indicated in Diagram (6) and Diagram (7); hardware resources are distributed wisely on need basis to different environments; all the virtual machines share the same resources and reduce resource wastage.</li><li><strong>Ease of quick administration and maintenance</strong>: It is easier to build, install, configure one server rather than multiple servers. Updating a patch on various machines from a single virtualized server is much more feasible.</li><li><strong>Disaster recovery</strong>: Since all the virtualized machines reside on the same server and are treated as mounted volumes of data files, it is easier to back up these machines. In case of a disaster failure (power failure, network down, cyber-attacks, failed test code, etc) VM screenshots are used to recover the running state of the machine and the whole setup can be built up within minutes.</li><li><strong>Isolated and independent secure test environment</strong>: virtualization provide an isolated independent virtual test environment to test the legacy code or a vendor-specific product or even a beta release or say a corrupt code without affecting the main hardware and software platform. (This is a contradictory statement though; will discuss more under types of virtualization)<br>These test environments like dev, uat, preprod, prod etc..can be easily tested and discarded.</li><li><strong>Easily scalable and upgradable</strong>: Building up more simulated environments means spinning up more virtual machines. Also upgrading VMs is as good as to run a patch in all VMs.</li><li><strong>Portable</strong>: Virtual machines are lightweight compared to the actual running physical machines; in addition, a VM that includes its own OS, drivers, and other installation files is portable on any machine. One can access the data virtually from any location.</li></ol><p>The screenshot of activity monitor below compares the CPU load:</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="implementation"></a><em>Implementation</em><a class="hash-link" href="#implementation" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="a-what-is-hypervisor-and-its-types__"></a><em>a) What is hypervisor and its types__?</em><a class="hash-link" href="#a-what-is-hypervisor-and-its-types__" title="Direct link to heading">#</a></h3><p>As discussed in the previous section; virtualization is achieved by means of a virtualized layer on top of hardware or a software resource.</p><p>This abstract layer is called a <em>hypervisor.</em></p><p>A hypervisor is a virtual machine monitor (VMM)</p><p>There are 2 types of hypervisors: Diagram (8)</p><ol><li>Type-1 or bare-metal hypervisor</li><li>Type-2 or hosted hypervisor</li></ol><p><em>Type-1 or bare-metal</em> hypervisor is installed directly on the system hardware, thus abstracting and sharing the hardware components with the VMs.</p><p><em>Type-2 or hosted hypervisor</em> is installed on top of the system bootable OS called host OS; this hypervisor abstracts the system resources visible to the host OS and distributes it among the VMs.</p><p>Both have their own role to play in virtualization.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="b-comparing-hypervisor-types"></a><em>b) Comparing hypervisor types</em><a class="hash-link" href="#b-comparing-hypervisor-types" title="Direct link to heading">#</a></h3><p>Type-1 or bare-metal hypervisor</p><p>Type-2 or hosted hypervisor</p><p>Installed <em>directly on the infrastructure</em>-OS independent and more secure against software issues.</p><p>Installed <em>on top of the host OS</em>-more prone to software failures.</p><p><em>Better resource flexibility</em>: Have direct access to the hardware infrastructure (Hard-drive partition, RAM, embedded cards such as NIC). Provide more flexibility and scalability to the VMs and assign resources on a need basis.</p><p><em>Limited resource allocation</em>: Have access to just the resources exposed by the host OS.</p><p>VMs installed will have limited access to hardware resources allocated and exposed by the host OS.</p><p>Single point of failure: A compromised VM may affect the kernel. Extra security layers needed.</p><p>A compromised VM may affect only the host OS, kernel still remains unreachable.</p><p>Low latency due to direct link to the infrastructure.</p><p>High latency as all the VMs have to pass through the OS layer to access the system resources.</p><p>Generally used in Servers</p><p>Generally used on small client machines</p><p>Expensive</p><p>Less expensive</p><p>Type-1 Hypervisors in market:</p><p>VMWare ESX/ESXi</p><p>Hyperkit (OSX)</p><p>Microsoft Hyper-V (Windows)<br>
KVM(Linux)</p><p>Oracle VM Server</p><p>Type-2 Hypervisors in market:</p><p>Oracle VM VirtualBox</p><p>VMWare Workstation</p><p>Parallels desktop for MAC</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="types-of-virtualization"></a><em>Types of virtualization</em><a class="hash-link" href="#types-of-virtualization" title="Direct link to heading">#</a></h2><p>Based on what resource is virtualized, there are different classifications of virtualization.</p><p>Server, Storage device, operating system, network</p><p><strong>Desktop</strong> <strong>virtualization</strong>: Entire desktop environment is simulated and distributed to run on a single server all at once. A desktop virtualization allows administrators to manage, install, configure similar setups on many machines. Upgrading all the machines with a single patch update or security checks becomes easier and faster.</p><p><strong>Server</strong> <strong>virtualization</strong>: Many dedicated servers can be virtualized into a single server that provides multi-server functionality.</p><p><strong>Example:</strong></p><p>Many virtual machines can be built up sharing the same underlying system resources.</p><p>Storage, RAM, disks, CPU</p><p><strong>Operating system</strong> <strong>virtualization</strong>: This happens at the kernel level Hypervisor on hardware type 2 bare-metal One machine: Can boot up as multiple OS like Windows or Linux side-by-side</p><p><strong>Application virtualization</strong>: Apps are packaged and stored in a virtual environment and are distributed across different VMs. Example Microsoft applications like excel, MS word, Powerpoint etc, Citrix applications.</p><p><strong>Network functions virtualization</strong>: Physical network components such as NIC cards, switches, routers, servers, hubs, and cables are all assembled in a single server and used virtually by multiple machines without having the load of installing them on every machine.</p><p>Virtualization is one of the building blocks and driving force behind <a href="https://www.ibm.com/cloud/learn/cloud-computing" target="_blank" rel="noopener noreferrer"><em>cloud computing</em></a>.</p><p>Cloud computing provide virtualized need-based services. This has given an uplift to the concept of virtualization.</p><p>A quick mention of various cloud computing models/services are listed below:</p><p><strong>SaaS</strong> ‚Äì Software as a Service‚Äì end-user applications are maintained and run by service providers and easily distributed and used by the end users without having to install them.</p><p>Top SaaS providers: Microsoft (Office suite, CRM, SQL server databases), AWS, Adobe, Oracle (ERP, CRM, SCM), Cisco‚Äôs <a href="https://www.webex.com/de/index.html" target="_blank" rel="noopener noreferrer">Webex</a>, <a href="https://github.com/" target="_blank" rel="noopener noreferrer">GitHub</a> ( git hosting web service)</p><p><strong>PaaS</strong> ‚Äì Platform as a Service ‚Äì computing infrastructure(hardware/software) is maintained and updated by the service provider and the user just have to run the product over this platform.</p><p>Top Paas providers: <a href="https://aws.amazon.com/elasticbeanstalk/" target="_blank" rel="noopener noreferrer">AWS beanstalk</a>, <a href="https://www.oracle.com/index.html" target="_blank" rel="noopener noreferrer">Oracle Cloud Platform (OCP)</a>, <a href="https://cloud.google.com/appengine/" target="_blank" rel="noopener noreferrer">Google App Engine</a></p><p><strong>IaaS</strong> ‚Äì Infrastructure as a Service ‚Äì Provide infrastructure such as servers, physical storage, networking, memory devices etc. Users can build their own platform with customized operating system and applications.</p><p>Key IaaS providers: Amazon Web Services, <a href="https://azure.microsoft.com/en-us/" target="_blank" rel="noopener noreferrer">Microsoft Azure</a>, Google compute engine, Citrix</p><p><strong>Conclusion:</strong></p><p>We now have a fair understanding of types of virtualization and how they are implemented.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="containerization"></a><strong>Containerization</strong><a class="hash-link" href="#containerization" title="Direct link to heading">#</a></h2><p>Though virtualization has its pros; there are certain downsides of virtualization such as:</p><ul><li>Not all systems can be virtualized always.</li><li>A corrupt VM is sometimes contagious and may affect other VMs or the kernel in-case of a <em>Type-1 or bare-metal</em> hypervisor.</li><li>Latency of virtual disks due to increased payload on the CPU resources with a higher number of VMs</li><li>Unstable performance</li></ul><p>An alternative approach to overcome the above flaws of virtualization is to <em>Containerize</em> the applications and the run-time environment together.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="what-is-containerization"></a><em>What is containerization</em><a class="hash-link" href="#what-is-containerization" title="Direct link to heading">#</a></h2><p><em>Containerization</em> is an OS-level virtualization; wherein the entire build of an application along with run-time environment is encapsulated or bundled up in a package.</p><p>These packages are called <em>containers</em>.</p><p>Containers are lightweight virtualized environments. These are independent of the infrastructure both hardware and software.</p><p>The run-time environment includes the operating system, binaries, libraries, configuration files and other applications as shown in Diagram (9).</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="what-is-dockers"></a><em>What is Dockers</em><a class="hash-link" href="#what-is-dockers" title="Direct link to heading">#</a></h2><p><em>Dockers</em> provide an excellent framework for containerization and allow to build, ship, and run distributed applications over multiple platforms.</p><p>Docker framework is setup as a <em>docker engine</em> installed on host OS and a <a href="https://www.knowledgehut.com/devops/docker-training" target="_blank" rel="noopener noreferrer">docker</a> <em>daemon</em> (background process) process is started that manage the virtual <em>containers</em>.</p><p>Refer Diagram (10) that shows a Docker engine with 3 containers residing on host OS (MAC OS).</p><p>An instruction file called <em>dockerfile</em> is written with a set of system commands that change the filesystem such as add, copy or delete commands, run commands, install utilities, system calls etc‚Ä¶</p><p>This <em>dockerfile</em> is built and packaged along with its run-time environment as an executable file called a <em>docker image.</em></p><p>Docker daemon services run these images to create <em>docker containers.</em></p><blockquote><p><em>Docker container is a run-time instance of an image</em></p></blockquote><p>It is wise to say that many images (or layers of instruction files) make up a container.</p><p>Docker containers have a compact packaging and each container is well isolated.</p><p>We can run, start, stop, attach, move or delete containers as these runs as services on the host OS.</p><p>Each image is made up of different layers; each image based on top of the other with the customized command changes that we make.</p><p>Every time we make a change in the filesystem, each change related to the image is encapsulated in a new layer of filesystem and stacked up above the parent image.</p><p>Only the changed layers are rebuilt, rest of the unchanged image layers are reused.</p><p>Certain docker commands ADD, RUN and COPY c<em>reate a new layer with increased byte size; rest of the commands simply adds up a new layer with zero-byte size.</em></p><p><em>These layers are re-used to build a new image, hence faster and lightweight.</em></p><p>Docker images are also</p><p>The layer approach of an image every time there is a change in the image makes it possible to Version control the docker images.</p><p>Here is a terminal recording that shows docker engine process and how images and containers are created.</p><p>Docker documentation - to <a href="https://docs.docker.com/get-started/part2/" target="_blank" rel="noopener noreferrer">create containers</a>.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="ppt-diagram"></a><strong>Ppt diagram:</strong><a class="hash-link" href="#ppt-diagram" title="Direct link to heading">#</a></h3><p>Code -&gt; package -&gt; build images -&gt; registry hub -&gt; download/pull image -&gt; run container</p><p>Animation: sheet4</p><p>Let‚Äôs consider the docker container: divyabhushan/learn_docker hosted on docker hub.</p><p>Latest tagged image: centOS_release1.2</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="what-is-the-container-environment"></a>What is the container environment?<a class="hash-link" href="#what-is-the-container-environment" title="Direct link to heading">#</a></h3><p>Base OS: Centos:7</p><p>Utilities: vim, yum, git</p><p>Apps/files: Dockerfile, myApp.sh, runtests.sh, data and other supporting files.</p><p>Git source code: <a href="https://github.com/divyabhushan/DockerImages_Ubuntu.git" target="_blank" rel="noopener noreferrer">dockerImages</a></p><p>Download as: git clone <a href="https://github.com/divyabhushan/DockerImages_Ubuntu.git" target="_blank" rel="noopener noreferrer">https://github.com/divyabhushan/DockerImages_Ubuntu.git</a></p><p>What does the container do?<br>
Container launches ‚ÄúmyApp.sh‚Äù in Ubuntu:14.04 environment and run some scripts along with a set of post test_suites in the container (Ubuntu:14.04) and saves the output log file.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="how-to-modify-and-build-your-own-app"></a><em>How to modify and build your own app</em><a class="hash-link" href="#how-to-modify-and-build-your-own-app" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="step-1-pull"></a><strong>Step 1: pull</strong><a class="hash-link" href="#step-1-pull" title="Direct link to heading">#</a></h3><p><strong>1.1: Pull the docker image</strong></p><p><strong>1.2: Run image to create a container and exit</strong></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="step-2-modify"></a><strong>Step 2: modify</strong><a class="hash-link" href="#step-2-modify" title="Direct link to heading">#</a></h3><p>2.1: Start the container</p><p>2.2: Attach to the container and make some changes</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="step-3-commit"></a><strong>Step 3: commit</strong><a class="hash-link" href="#step-3-commit" title="Direct link to heading">#</a></h3><p>3.1: Examine the history logs and changes in the container</p><p>3.2: Commit the changes in container</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="step-4-push"></a><strong>Step 4: push</strong><a class="hash-link" href="#step-4-push" title="Direct link to heading">#</a></h3><p>4.1: Push new image to docker hub</p><p>Let us see the steps in action:</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="step-1-pull-1"></a><strong>Step 1: pull</strong><a class="hash-link" href="#step-1-pull-1" title="Direct link to heading">#</a></h3><p>docker image on your machine</p><p>1.1: Pull the docker image</p><p><strong>Command:</strong></p><p>docker pull divyabhushan/learn_docker:myApp_ubuntu_14.04</p><p>View the image on system</p><p>docker images</p><p>screenshot</p><p><strong>Command:</strong></p><p>docker run -it --name ubuntu14.04 0a6f949131a6</p><p>Run command in ubuntu container and exit, the container is stopped on exiting out.</p><p>View the stopped container with the ‚Äòps -a‚Äô command.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="step-2-modify-1"></a><strong>Step 2: modify</strong><a class="hash-link" href="#step-2-modify-1" title="Direct link to heading">#</a></h3><p>Start the container</p><p><strong>Command:</strong></p><p>docker start &lt;container_id&gt;</p><p>Now the container is listed as a running process Attach to the container and make some changes</p><p><strong>Command:</strong></p><p>docker attach 7d0d0225778c</p><p>edit the ‚Äògit configuration‚Äô file and ‚ÄòmyApp.sh‚Äô script</p><p>Container is modified and stopped</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="step-3-commit-1"></a><strong>Step 3: commit</strong><a class="hash-link" href="#step-3-commit-1" title="Direct link to heading">#</a></h3><p>Examine the history logs and changes in the container</p><p>The changes done inside the container filesystem can be viewed using the ‚Äòdocker diff‚Äô command as:</p><p><strong>Command:</strong> </p><p>docker diff 7d0d0225778c</p><p>Commit the changes in container</p><p>Docker commit:</p><p>Usage: docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</p><p>docker commit -m &#x27;new Ubuntu image&#x27; 7d0d0225778c divyabhushan/learn_docker:ubuntu14.04_v2</p><p>New image is created and listed</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="step-4-push-1"></a><strong>Step 4: push</strong><a class="hash-link" href="#step-4-push-1" title="Direct link to heading">#</a></h3><p>Push new image to docker hub</p><p><strong>Command:</strong></p><p>docker push divyabhushan/learn_docker:ubuntu14.04_v2</p><p>Point to note: just the latest commit change layer ‚Äò50a5ce553bba‚Äô has been pushed, while the other layers were re-used.</p><p>Image available on docker hub:</p><p>The latest tagged image can now be pulled from other machines; and run to create the same container environment.</p><p><strong>Conclusion</strong>: An image was pulled and run to create a container to replicate the environment. Container was modified, new changes were committed to form a new image. New Image pushed back on the docker hub and now available as a new tag ready to be pulled by other machines.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="difference-between-dockers-and-virtual-machines"></a><strong>Difference between Dockers and Virtual machines</strong><a class="hash-link" href="#difference-between-dockers-and-virtual-machines" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="tabular-differences-on-various-parameters"></a><em>Tabular differences on various parameters</em><a class="hash-link" href="#tabular-differences-on-various-parameters" title="Direct link to heading">#</a></h3><p>Parameters</p><p>VMs</p><p>Dockers</p><p>architecture  </p><p><em>Hardware level virtualization</em>. Each VM has its own copy of OS.  </p><p><em>Software level virtualization</em>. Dockers have no own OS, run on host OS</p><p>Isolation</p><p>Fully isolated</p><p>Process or application-level isolation. ¬†</p><p>Installation</p><p>Hypervisor can <em>run directly on the hardware</em> resources or <em>on the host OS</em>.</p><p>Docker engine is installed <em>on top of the host OS</em>. A docker daemon process is initiated on the host OS. There is no separate OS for every container.</p><p>CPU processing + performance</p><p><em>Slower</em>: A VM contains the entire run-time environment that has to be loaded every time. Uses more CPU cycles; gives unstable performance.</p><p><em>Faster</em>: Docker images are pre-built and share host resources as a result running an image as a container is lightweight and consumes less CPU cycle; gives a stable performance</p><p>Hardware storage</p><p>More storage space as each VM is an independent machine (OS). Example: 3 VMs of 800MB each will take 2.4 GB of space.</p><p>Docker containers are lightweight since do not require to load OS+drivers, run on host OS as processes.</p><p>Portable</p><p>Dependency on host OS and hardware makes VM less portable. Importing a VM still requires manual setup such storage, RAM and network.</p><p>Highly portable since lightweight and zero dependency on hardware.</p><p>Scalable and code-reusability</p><p>Spinning up more VMs still need administrative tasks such as distributing resources to VM. Running a new machine puts extra load on the system resources also re-managing earlier VMs becomes a task. Every VM keeps its own copy of resources-poor code-reusability.</p><p>Spinning up new docker containers simply means running pre-built images into containers as a process inside host OS. Containers are also configured on-the-fly passing parameters and run-time. Single image can be run and used to create many containers; encourage code-reusability</p><p>Resource utilization</p><p>Static allocation results in resource wastage in case of idle VMs or if a VM‚Äôs resource requirement increases.</p><p>Resources are dynamically allocated and de-allocated on the need basis by the docker engine.</p><p>Docker system prune or garbage collection</p><p>Virtual machines do not have an in-built prune mechanism, these have to be <em>administered manually</em>.</p><p>Docker image and containers can be pruned; which frees up a sensible amount of storage and memory space and CPU cycles.</p><p>New environment</p><p>Creating new VM from the scratch is a tedious, repetitive tasks. It involves installing a new OS, loading kernel drivers and other tools and configurations.</p><p>Package the code and dependency files, build into an image, run the image to create a new container. Use an existing or a base image (dockerhub- <a href="https://hub.docker.com/_/scratch" target="_blank" rel="noopener noreferrer">scratch</a>) to run and create more containers on the go.</p><p>Web-hosted Hub</p><p>No web hosted hub for VMs</p><p><a href="https://hub.docker.com/search/?type=image" target="_blank" rel="noopener noreferrer">dockerHub</a> provides an open-source reliable trusted source of pre-built images that can be downloaded to run new containers.</p><p>Version control (backup, restore,track history)</p><p>(refer <a href="https://www.knowledgehut.com/tutorials/git-tutorial/introduction-to-git" target="_blank" rel="noopener noreferrer">git</a>)</p><p>Snapshot of VMs are not very user-friendly and consume more space.</p><p>Docker images are version controlled. </p><p>Every delta difference in each docker container can easily be viewed (demo: docker diff &lt;container_id&gt;). </p><p>Any change in the image is stored as a different layered version. A reference link to older images saves build time and space.</p><p>Auto-build</p><p>Automation of creating VMs is not very feasible.</p><p>Docker images can also be auto-built from every source code check-in to GitHub (Automated builds on Dockerhub)</p><p>Disaster recovery</p><p>Tedious to recover from VM backup files.</p><p>Easier to restore docker images (like files) just like git source files in case images are version controlled. Backup images only have to be run to create containers. (refer: screenshot).</p><p>Update</p><p>All the VMs have to updated with the release patch.</p><p>A single image is updated, re-built and distributed across multiple platforms.</p><p>Memory usage+speed</p><p>Slower: Entire snapshot of a machine and the OS is loaded into the cache memory.</p><p>Real-time and fast: pre-built images. Only the instance, i.e, a container has to be run as a process and uses memory like an executable</p><p>Data integrity</p><p>VM behavior may change if the dependency includes beyond the VM boundaries. (example: an app depends on production host network settings)</p><p>Same behavior of apps in any environment</p><p>security</p><p>More secure: A failure inside a VM may reach its guest OS but not the host OS or other virtual machines. Type-2 hypervisor though has a risk of kernel attack.</p><p>Less secure: If a docker container compromised; underlying OS and hence all the containers may be affected since they share the same host kernel. OS Kernel may also be risked.</p><p>Key providers</p><p><a href="https://www.redhat.com/en/topics/virtualization/what-is-KVM" target="_blank" rel="noopener noreferrer">Red hat KVM</a>, VMWare, Oracle VM VirtualBox, Mircrosoft Hyper-V, Citrix XenServer</p><p><a href="https://www.mirantis.com/software/docker/docker-enterprise/" target="_blank" rel="noopener noreferrer">Dockers</a>,¬†<a href="https://cloud.google.com/kubernetes-engine/" target="_blank" rel="noopener noreferrer">Google kubernetes Engine</a>,¬†<a href="https://aws.amazon.com/ecs/" target="_blank" rel="noopener noreferrer">AWS Elastic Container service</a></p><p>Data authentication</p><p>Lot of software licenses.</p><p>Docker maintains inbuilt content trust to verify published images.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="when-to-use-vm-or-a-docker"></a><em>When to use VM or a Docker</em><a class="hash-link" href="#when-to-use-vm-or-a-docker" title="Direct link to heading">#</a></h2><p>When the need is an isolated OS, go for VMs.</p><p>For a hardware and software independent isolated application that needs fast distribution on multiple environments, use dockers.</p><ul><li><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="docker-use-case"></a>Docker use-case:<a class="hash-link" href="#docker-use-case" title="Direct link to heading">#</a></h3></li></ul><p>Example: A database application along with its database</p><p>Consider the docker image - <a href="https://hub.docker.com/_/oracle-weblogic-server-12c?tab=description" target="_blank" rel="noopener noreferrer">Oracle WebLogic Server</a> on <a href="https://hub.docker.com/" target="_blank" rel="noopener noreferrer">Docker Hub</a>.</p><p>This image is pre-built Oracle WebLogic Server runtime environment, including Oracle Linux 7 and Oracle JDK 8 for deploying Java EE applications.</p><p>To create Server configurations on any machine, just download this image and run to create and start a container.</p><p>There is no need to install and configure JDK, Linux or other run-time environment.</p><ul><li><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="do-not-use-docker-use-case"></a>Do not use Docker use-case:<a class="hash-link" href="#do-not-use-docker-use-case" title="Direct link to heading">#</a></h3></li></ul><p>The application depends on utility outside the docker container.</p><p>Code developed on dev machine with base OS as MAC; needs certain firewall setting on say Ubuntu OS.</p><p>How can the code be tested on the production ubuntu OS firewall while running from MAC OS docker container?</p><p>Solution: ¬†Install a virtualization software on host OS-MAC; Create a VM (Virtual machine) with host OS as Ubuntu (same as production environment).</p><p>Configure the desired firewall settings on host VM ‚Äì Ubuntu; import the test code inside Ubuntu and test.</p><ul><li><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="use-a-vm"></a>Use a VM:<a class="hash-link" href="#use-a-vm" title="Direct link to heading">#</a></h3></li></ul><p>For Embedded systems programming, a VM is installed that connects to the system device drivers, controllers and kernel.</p><ul><li><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="virtualization-used-along-with-docker"></a>Virtualization used along with docker:<a class="hash-link" href="#virtualization-used-along-with-docker" title="Direct link to heading">#</a></h3></li></ul><p>An extension to the previous scenario would be if you would want to also test your python application in the host OS-Ubuntu VM without having to set up the python exe and its libraries and binaries.</p><p>All you have to do is: Install <a href="https://www.knowledgehut.com/devops/docker-training" target="_blank" rel="noopener noreferrer">Docker</a> engine for Ubuntu OS and pull the python image from Docker hub as:</p><p>docker pull python:tag [ tag is the python version-choose the appropriate version ]</p><p>docker pull python:2.7</p><p>Refer: <a href="https://hub.docker.com/_/python/" target="_blank" rel="noopener noreferrer">Python image</a></p><p>Either write a Dockerfile to import/copy entire source code to python environment or directly run the image passing the script path as below:</p><p>Command:</p><p>$docker run -it --name my-python-script -v ‚Äú$PWD‚Äù:/usr/src/myapp -w /usr/src/myapp python:2.7 python my-application.py</p><p>Command options:</p><p>-v = volume list-bind mount a volume [mount present working directory onto /usr/src/myapp inside container]</p><p>-w = workdir string-working directory inside the container</p><p>Moreover; you can also test your python code in more than one version by downloading different python images, running them to create different containers and running your app in each container.</p><p>What‚Äôs exciting here is that once the code tested in each python environment; you could quickly work on the test results and drop the containers. And deploy the code to production only once code tested against various python versions.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="final-thoughts"></a><em>Final thoughts</em><a class="hash-link" href="#final-thoughts" title="Direct link to heading">#</a></h4><p>VMs and dockers are compatible with each other. Dockers are not here to replace Virtual machines.</p><p>Both serve the same purpose of virtualizing the computing and infrastructure resources for optimized utilization.</p><p>Using both Virtual machines and dockers together can yield better results in virtualization.</p><p>When one desires a fast, lightweight, portable and highly scalable hardware-independent environment for multiple applications isolation; wherein security is not the major concern; Dockers is the best choice.</p><p>Use a VM for embedded systems that are integrated with hardware; such as device driver or kernel coding.</p><p>A scenario simulating an infrastructure setup with a high resource control and dependency on system resources; VMs are a better choice.</p><p>Use of Dockers inside VM</p><p>CI/CD pipelines scenario:</p><p>Virtualization enables a smooth CI/CD process flow by promoting the users to concentrate only on developing the code on a working system that is set up for automated continuous integration and deployment without having to duplicate the entire setup each time.</p><p>A virtualized environment is set up; either using a VM or a docker image that takes care of the automatic code check-ins, builds, regression testing, and deployments on the server.</p></div></article><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Docs pages navigation"><div class="pagination-nav__item"></div><div class="pagination-nav__item pagination-nav__item--next"></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#what-a-machine-need" class="table-of-contents__link"><strong>What a machine need?</strong></a></li><li><a href="#how-to-manage-huge-data---servers" class="table-of-contents__link"><strong>How to manage huge data - Servers</strong></a><ul><li><a href="#many-servers-approach-challenge" class="table-of-contents__link"><strong>Many Servers approach challenge:</strong></a></li></ul></li><li><a href="#virtualization" class="table-of-contents__link"><strong>Virtualization</strong></a><ul><li><a href="#what-is-virtualization" class="table-of-contents__link">What is Virtualization</a></li><li><a href="#what-is-a-virtual-machine" class="table-of-contents__link"><em>What is a Virtual machine</em></a></li><li><a href="#need-for-virtualization" class="table-of-contents__link"><em>Need</em> <em>for</em> <em>virtualization</em></a></li></ul></li><li><a href="#implementation" class="table-of-contents__link"><em>Implementation</em></a><ul><li><a href="#a-what-is-hypervisor-and-its-types__" class="table-of-contents__link"><em>a) What is hypervisor and its types__?</em></a></li><li><a href="#b-comparing-hypervisor-types" class="table-of-contents__link"><em>b) Comparing hypervisor types</em></a></li></ul></li><li><a href="#types-of-virtualization" class="table-of-contents__link"><em>Types of virtualization</em></a></li><li><a href="#containerization" class="table-of-contents__link"><strong>Containerization</strong></a></li><li><a href="#what-is-containerization" class="table-of-contents__link"><em>What is containerization</em></a></li><li><a href="#what-is-dockers" class="table-of-contents__link"><em>What is Dockers</em></a><ul><li><a href="#ppt-diagram" class="table-of-contents__link"><strong>Ppt diagram:</strong></a></li><li><a href="#what-is-the-container-environment" class="table-of-contents__link">What is the container environment?</a></li></ul></li><li><a href="#how-to-modify-and-build-your-own-app" class="table-of-contents__link"><em>How to modify and build your own app</em></a><ul><li><a href="#step-1-pull" class="table-of-contents__link"><strong>Step 1: pull</strong></a></li><li><a href="#step-2-modify" class="table-of-contents__link"><strong>Step 2: modify</strong></a></li><li><a href="#step-3-commit" class="table-of-contents__link"><strong>Step 3: commit</strong></a></li><li><a href="#step-4-push" class="table-of-contents__link"><strong>Step 4: push</strong></a></li><li><a href="#step-1-pull-1" class="table-of-contents__link"><strong>Step 1: pull</strong></a></li><li><a href="#step-2-modify-1" class="table-of-contents__link"><strong>Step 2: modify</strong></a></li><li><a href="#step-3-commit-1" class="table-of-contents__link"><strong>Step 3: commit</strong></a></li><li><a href="#step-4-push-1" class="table-of-contents__link"><strong>Step 4: push</strong></a></li></ul></li><li><a href="#difference-between-dockers-and-virtual-machines" class="table-of-contents__link"><strong>Difference between Dockers and Virtual machines</strong></a><ul><li><a href="#tabular-differences-on-various-parameters" class="table-of-contents__link"><em>Tabular differences on various parameters</em></a></li></ul></li><li><a href="#when-to-use-vm-or-a-docker" class="table-of-contents__link"><em>When to use VM or a Docker</em></a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">
      <div class="footer">
      <p style="float:left">
      Copyright ¬© 2021 Divya Bhushan.
      </p>
      <p style="float:right">
      <a href="https://www.linkedin.com/in/divyabhushan/" target="_blank" style="padding-left:10px"><img src="https://github.com/divyabhushan/my-portfolio/blob/gh-pages/img/linkedin.png?raw=true" width="40">
      <a href="https://divya-bhushan.medium.com/" target="_blank" style="padding-left:10px"><img src="https://github.com/divyabhushan/my-portfolio/blob/gh-pages/img/medium.png?raw=true" width="40"></a>
      </p><p>
      </p></div>
      </div></div></div></footer></div>
<script src="/my-portfolio/assets/js/runtime~main.d2cc5123.js"></script>
<script src="/my-portfolio/assets/js/main.3f25e7fb.js"></script>
</body>
</html>